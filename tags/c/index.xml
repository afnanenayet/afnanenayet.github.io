<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on Afnan Enayet</title>
    <link>https://afnan.io/tags/c/</link>
    <description>Recent content in C on Afnan Enayet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Oct 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://afnan.io/tags/c/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using the Latest LLVM Release on MacOS</title>
      <link>https://afnan.io/post/2018-10-01-using-the-latest-llvm-release-on-macos/</link>
      <pubDate>Mon, 01 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://afnan.io/post/2018-10-01-using-the-latest-llvm-release-on-macos/</guid>
      <description>MacOS is really frustrating with how it handles its libraries and compilers. It is also frustrating because it ships an unspecified version of LLVM, which generally isn&#39;t the latest stable release. You can, however, with a little tweaking, use the latest version of LLVM or GCC on your Mac, and reliably use it for your C and C++ tooling.
Installation First, you need to install the latest version of LLVM. Most people nowadays are using Homebrew.</description>
    </item>
    
    <item>
      <title>My Neovim Development Setup</title>
      <link>https://afnan.io/post/2018-04-12-my-neovim-development-setup/</link>
      <pubDate>Thu, 12 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://afnan.io/post/2018-04-12-my-neovim-development-setup/</guid>
      <description>It&#39;s been a while since I wrote about my Neovim setup. Since my last post, my nvim config has grown to be a little more sophisticated, and I finally worked out autocompletion and linting for all of the languages I work with.
Here&#39;s what my editor looks like:

I have posted my full neovim configuration on Github
Split up your init.vim I had a horribly long init.vim file before. It gets clunky to manage and long files are ugly.</description>
    </item>
    
    <item>
      <title>Exposing terminal variables with C</title>
      <link>https://afnan.io/post/2017-09-27-exposing-terminal-variables-with-c/</link>
      <pubDate>Wed, 27 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://afnan.io/post/2017-09-27-exposing-terminal-variables-with-c/</guid>
      <description>I was writing a C program that took in some arguments and printed those arguments when I encountered some unexpected output -- all of my terminal variables.
Code The code to print out a number of variables is as follows, (I decided to continue printing variables through UNSIGNED_LONG).
/* Afnan Enayet leak_data.c * * A script written to read terminal variables */ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;limits.h&amp;gt; /****** function prototypes ******/ void print_vars(char **args); /****** function definitions ******/ int main(int argc, char *argv[]) { print_vars(argv); return 0; } void print_vars(char **args) { const unsigned long loop_limit = ULONG_MAX; // Reading arguments from memory addresses outside of the program // (should bleed into term vars) // Prints lines in the following format.</description>
    </item>
    
    <item>
      <title>Debugging C with GDB and Valgrind</title>
      <link>https://afnan.io/post/2017-07-29-debugging-c-with-gdb-and-valgrind/</link>
      <pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://afnan.io/post/2017-07-29-debugging-c-with-gdb-and-valgrind/</guid>
      <description>Debugging C can be a chore, but being able to pinpoint your memory leaks with Valgrind and monitoring the flow of your program with GDB (or LLDB) can speed up the development of your code significantly. It&#39;s a significant improvement over sticking a bunch of printf statements in your code and taking them out before production (which should by no means be your sole tool for debugging).
Setup Installing gdb is pretty easy on both OS X and Linux.</description>
    </item>
    
    <item>
      <title>A Primer on Pointers</title>
      <link>https://afnan.io/post/2017-07-27-a-primer-on-pointers/</link>
      <pubDate>Thu, 27 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://afnan.io/post/2017-07-27-a-primer-on-pointers/</guid>
      <description>A lot of people have trouble grasping manual memory management when they first encounter it. The syntax can be a little confusing and debugging can be an extremely painful process - whether you have a segfault or Valgrind is complaining that you still have memory leaks.
Using pointers in C, while a little intimidating at first, is not as difficult as most people expect.
C gives you a lot of access to memory - you can allocate bytes for use in your program, you can deallocate them, you can directly access memory addresses in your program, and pass them around wherever you want.</description>
    </item>
    
    <item>
      <title>Setting up Neovim</title>
      <link>https://afnan.io/post/2017-07-12-supercharge-nvim/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://afnan.io/post/2017-07-12-supercharge-nvim/</guid>
      <description>Note: You can find an updated version of this article here
 Vim is an excellent text editor. It&#39;s fast and has a light footprint, and tends to be installed in most Unix systems you&#39;ll come across. You can use it across SSH, and once you get the hang of the keybindings, you&#39;ll find that it&#39;s actually very fast to use.
Neovim tries to strip some of the cruft of Vim.</description>
    </item>
    
  </channel>
</rss>