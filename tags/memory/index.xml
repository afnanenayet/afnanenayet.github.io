<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>memory on Afnan Enayet</title>
    <link>https://afnan.io/tags/memory/</link>
    <description>Recent content in memory on Afnan Enayet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Sep 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://afnan.io/tags/memory/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Exposing terminal variables with C</title>
      <link>https://afnan.io/post/2017-09-27-exposing-terminal-variables-with-c/</link>
      <pubDate>Wed, 27 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://afnan.io/post/2017-09-27-exposing-terminal-variables-with-c/</guid>
      <description>I was writing a C program that took in some arguments and printed those arguments when I encountered some unexpected output -- all of my terminal variables.
Code The code to print out a number of variables is as follows, (I decided to continue printing variables through UNSIGNED_LONG).
/* Afnan Enayet leak_data.c * * A script written to read terminal variables */ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;limits.h&amp;gt; /****** function prototypes ******/ void print_vars(char **args); /****** function definitions ******/ int main(int argc, char *argv[]) { print_vars(argv); return 0; } void print_vars(char **args) { const unsigned long loop_limit = ULONG_MAX; // Reading arguments from memory addresses outside of the program // (should bleed into term vars) // Prints lines in the following format.</description>
    </item>
    
    <item>
      <title>Debugging C with GDB and Valgrind</title>
      <link>https://afnan.io/post/2017-07-29-debugging-c-with-gdb-and-valgrind/</link>
      <pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://afnan.io/post/2017-07-29-debugging-c-with-gdb-and-valgrind/</guid>
      <description>Debugging C can be a chore, but being able to pinpoint your memory leaks with Valgrind and monitoring the flow of your program with GDB (or LLDB) can speed up the development of your code significantly. It&#39;s a significant improvement over sticking a bunch of printf statements in your code and taking them out before production (which should by no means be your sole tool for debugging).
Setup Installing gdb is pretty easy on both OS X and Linux.</description>
    </item>
    
    <item>
      <title>A Primer on Pointers</title>
      <link>https://afnan.io/post/2017-07-27-a-primer-on-pointers/</link>
      <pubDate>Thu, 27 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://afnan.io/post/2017-07-27-a-primer-on-pointers/</guid>
      <description>A lot of people have trouble grasping manual memory management when they first encounter it. The syntax can be a little confusing and debugging can be an extremely painful process - whether you have a segfault or Valgrind is complaining that you still have memory leaks.
Using pointers in C, while a little intimidating at first, is not as difficult as most people expect.
C gives you a lot of access to memory - you can allocate bytes for use in your program, you can deallocate them, you can directly access memory addresses in your program, and pass them around wherever you want.</description>
    </item>
    
  </channel>
</rss>